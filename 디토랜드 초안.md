# 디토랜드 초안

## Lua 언어를 사용하는 이유

> 디토랜드에서 사용 할 수 있는 언어가 Lua언어이기 때문이다.
> 
1. Lua 에서 변수는 자료형 표기 없이 Local로 선언합니다.
2. Lua 에서 함수는 자료형 표기 없이 선언합니다. 
3. Lua 에서 리스트는 table로 구현 할 수 있습니다. 
4. Lua 에서 switch 문은 존재하지 않습니다.

# wait함수

> wait함수란?
> 

wait 함수는 대기 함수이다.

wait 함수를 사용하면 지정한 시간만큼 다음 코드의 실행을 멈춘다.

# Lua언어에서의 wait와 디토랜드 Wait의 차이

> Lua언어에서의 Wait()
> 

루아에서는 시간지연 함수인 wait()을 만들어 사용해야한다.

```lua
function wait(first)
	local start = os.time()
	repeat until os.time() >= start + first
	end

print("5초 기다려 주세요") //출력
wait(5) //5초를 기다린 후
print("잘하셨습니다.!") //출력
```

1. function을 사용하여 wait(first) 함수를 만든다.
2. start를 os.time()으로 지정 //os.time()은 코드가 실행되었을 때의 시간을 나타낸다.
3. os.time()이 스타트의 os.time()과 first의 값을 합친 값보다 크거나 같을 때까지 반복
4. 즉 코드를 first만큼 반복함

아래 wait(5)를 입력하여 5초를 기다린다.

> 디토랜드에서의 Wait()
> 

디토랜드에서는 Wait() 함수를 내장하고 있어서 Lua언어보다 간단하다.

```lua
print("5초 기다려 주세요") //출력
wait(5) //5초를 기다린 후
print("잘하셨습니다!") //출력
```

++코드 설명 내장함수라서 바로 호출 사용 가능 // 어떻게 적어야할지 몰르겠다.

1. 5초 기다려 주세요 출력
2. 5초 기다림
3. 잘하셨습니다! 출력

# Coroutine(코루틴)

동시에 여러 작업을 처리할 수 있도록 독립적인 흐름을 만들어 줄 수 있는 방법이다
보통은 **동기방식** 즉, 하나의 작업을 끝내고 다른 작업을 처리할 수 있다면, Coroutine은 동시에 작업을 처리할 수 있도록 해준다. 코루틴은 **비동기방식**으로 이루어진 것이라 보면 된다.  

**동기**는 작업 처리 요청을 보낸 후 처리에 대한 결과(응답)를 받아야지만 다음 작업을 수행할 수 있는 방식을 말한다.모든 작업은 순차적으로 실행되며, 현재 어떤 작업이 수행 중이라면 다음 작업은 대기하게 된다.**비동기**는 병렬적으로 태스크(task, 작업)를 수행한다.

**동기 방식**은 설계가 매우 간단하고 직관적이지만, 작업을 직렬 처리하기 때문에 결과가 주어질 때까지 아무 것도 못하고 대기해야 하는 단점이 있다

**비동기 방식**은 동기 방식에 비해 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 대기없이 다른 작업을 병렬 처리할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있다.

-그림 부분- 

+++화살표를 1초 대기 후 출력 등등 언어를 포함 

+++그림 위에 동기 , 비동기 써놓기 

+++ 그림은 범직이 한테 부탁

+++ 동기 방식에 대한 그림 글을 자르고 단락 정리 제대로 하기 

![Untitled](%E1%84%83%E1%85%B5%E1%84%90%E1%85%A9%E1%84%85%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%8E%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%209298f4a2969a42f6bc15b60718d59dff/Untitled.png)

# Coroutine 라이브러리 목록

| 함수명 | 설명 |
| --- | --- |
| coroutine.create() | coroutine 생성 |
| coroutine.resume() | coroutine (재)실행 |
| coroutine.yield() | coroutine 일시정지 |
| coroutine.status() | coroutine의 상태 반환 |
| coroutine.wrap() | 함수 형태로 호출 가능한 coroutine 생성 |

# Coroutine사용법

### coroutine.create(함수 or 익명함수)

익명함수는 무엇일까요? 

> 익명함수
> 

익명 함수는 이름이 없는 함수로, 함수 이름 없이 정의된 함수 코드를 변수에 저장하는 방식이다.

익명 함수는 함수 이름이 없기 때문에 익명 함수를 사용할 때에는 익명 함수를 저장하고 있는 변수 이름을 함수 이름처럼 호출하여 사용하면 된다. 익명 함수는 사용하지 않는 동안에는 불필요한 메모리를 차지하지 않기 때문에 효율적인 메모리 관리 등을 위해 사용한다.

변수에 익명 함수를 대입하는 문장은 한 문장이므로, 반드시 마지막에 세미콜론을 붙여야 한다는 것을 유의해야 한다.

```lua
local 변수명 = function(매개 변수)
{
	실행문;
};
```

> 새로운 코루틴을 생성하지만, 실행하지는 않는다
> 

coroutine.create로 coroutine을 생성한다. (coroutine이 실행 되지 않는다.)

```lua
--매개변수를 사용하지 않을 경우
local co1 = coroutine.create(function()
    print("hello coroutine")
end)

--매개변수를 사용할 경우
local co2 = coroutine.create(function(message)
    print(message)
end) 
```

> 여기서 매개변수란?
> 
- 매개변수란  그림에서 보시는 것처럼 함수를 정의할 때 사용되는 변수를 의미합니다.

![Untitled](%E1%84%83%E1%85%B5%E1%84%90%E1%85%A9%E1%84%85%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%8E%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%209298f4a2969a42f6bc15b60718d59dff/Untitled%201.png)

### coroutine.resume(코루틴 이름, 매개변수)

생성/일시정지 된 코루틴을 (재)실행 합니다
일시정지 후, 재실행을 하면 일시정지 된 부분에서부터 시작합니다

![코루틴 인수와 매개변수.jpg](%E1%84%83%E1%85%B5%E1%84%90%E1%85%A9%E1%84%85%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%8E%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%209298f4a2969a42f6bc15b60718d59dff/%EC%BD%94%EB%A3%A8%ED%8B%B4_%EC%9D%B8%EC%88%98%EC%99%80_%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98.jpg)

> 여기서 인수란?
> 

매개변수에 넣어질 값이다.

### coroutine.yield()

실행중인 코루틴 일시정지합니다. yield는 코루틴 내에서 사용해야합니다.

```lua
local co1 = coroutine.create(function()
    for i = 1, 5 do
        if i == 4 then
            coroutine.yield() --coroutine 내에서 사용해요. (i == 4일 때 정지)
        end
        print("num : " .. i)
    end
end)
coroutine.resume(co1)  --1 ~ 3까지 출력

wait(1)                --1초 후 
print("재시작")         --재시작
coroutine.resume(co1)  --4 ~ 5 출력 (일시정지한 i == 4부터 다시 시작)
>num : 1
num : 2
num : 3
```

+++모든 예제 디토랜드에서 재실행 해서 예제 다시 정리 하고, 답 정리 하기 

### coroutine.status(코루틴)

코루틴 상태를 반환합니다. 코루틴의 상태는 running (실행 중) / suspend (정지) / dead (종료) 가 있습니다.

```lua
local co = coroutine.create(function()
    for i = 1, 5 do
        if i == 4 then
            coroutine.yield() --coroutine 내에서 사용해요.
        end
        print("num : " .. i)
    end
end)
coroutine.resume(co)         --1 ~ 3까지 출력
print(coroutine.status(co))  --suspend

print("재시작")               --재시작

coroutine.resume(co)         --4 ~ 5 출력
print(coroutine.status(co))  --dead
>num : 1
num : 2
num : 3
suspended
재시작
num : 4
num : 5
dead
```

> 코드설명
> 
1. 

### coroutine.wrap(함수 or 익명함수)

함수로 이용가능한 코루틴 생성합니다.wrap을 사용하면 yield로 정지 후 resume을 사용하지 않고 재시작할 수 있습니다. 

```lua
--wrap을 사용하면 yield로 정지 후 재시작할 때 resume을 사용할 필요가 없어요.

local co = coroutine.wrap(function()
    for i = 1, 5 do
        print("num : " .. i)
        coroutine.yield() --coroutine 내에서 사용해요.
    end
end)
co() -- num : 1
co() -- num : 2
co() -- num : 3
co() -- num : 4
co() -- num : 5
>num : 1
num : 2
num : 3
num : 4
num : 5
```

# Coroutine 과 wait 을 이용한 예제 (신호등 만들기)

초록과 빨강으로 만들기

상열이는 예제들 제대로 4거리로 구현해서 완성 시켜 주세요.

> 프로 젝트 계획
> 

신호등 예제 제작,math,random을 사용한 예제 제작, 후 드림팀 프로젝트 시작.